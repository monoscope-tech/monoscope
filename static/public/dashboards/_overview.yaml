title: Overview
icon: qrcode
preview: /public/assets/svgs/screens/http-stats.svg
description: Comprehensive system overview with service, resource, and database insights
refresh_interval: 60s

# Constants are query results executed once and reusable across all widgets
# They are available as {{const-<key>}} placeholders that expand to a subquery
constants:
  - key: top_resources
    description: Top 20 resources by request count for the current time range
    sql: |
      SELECT name
      FROM otel_logs_and_spans
      WHERE project_id='{{project_id}}'
        AND name IS NOT NULL
        AND kind = 'server'
        AND ('{{var-resource}}' = '' OR name = '{{var-resource}}')
        {{time_filter}}
      GROUP BY name
      ORDER BY COUNT(*) DESC
      LIMIT 20

variables:
  - key: service
    title: Service
    type: query
    reload_on_change: true
    sql: |
      SELECT DISTINCT resource___service___name 
      FROM otel_logs_and_spans 
      WHERE project_id='{{project_id}}' 
        AND resource___service___name IS NOT NULL 
        {{time_filter}}
      LIMIT 100
    default: ''
    multi: false

  - key: resource
    title: Resource/Operation
    type: query
    reload_on_change: true
    sql: |
      SELECT DISTINCT 
        name as value,
        name as label
      FROM otel_logs_and_spans
      WHERE project_id='{{project_id}}'
        AND resource___service___name = '{{var-service}}'
        AND name IS NOT NULL
        {{time_filter}}
      LIMIT 500
    default: ''
    multi: false
    depends_on: service

  - key: database
    title: Database System
    type: query
    sql: |
      SELECT DISTINCT attributes___db___system___name
      FROM otel_logs_and_spans
      WHERE project_id='{{project_id}}'
        AND attributes___db___system___name IS NOT NULL
        {{time_filter}}
      LIMIT 50
    default: ''
    multi: false

widgets: [] # Empty widgets array for backward compatibility

tabs:
  - name: Overview
    icon: grid
    widgets:
      # Golden Signals - The 4 key metrics for any APM
      - type: group
        title: Golden Signals
        description: 'The four key metrics from Google SRE for monitoring distributed systems: Traffic, Latency, Errors, and Saturation.'
        layout: { w: 12, h: 4 }
        children:
          - type: 'timeseries_stat'
            title: 'Traffic'
            description: 'Incoming request rate. Measures system load and usage patterns.'
            icon: activity
            query: |
              (kind == "server" or name == "apitoolkit-http-span" or name == "monoscope.http")
              | summarize count() by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: req/min
            layout: { w: 3, h: 2 }

          - type: 'timeseries_stat'
            title: 'P95 Latency'
            description: '95th percentile response time. 95% of requests complete faster than this.'
            icon: clock
            query: |
              (kind == "server" or name == "apitoolkit-http-span" or name == "monoscope.http") and duration != null
              | summarize p95(duration) / 1000000 by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: ms
            layout: { w: 3, h: 2 }

          - type: 'timeseries_stat'
            title: 'Error Rate'
            description: 'Percentage of failed requests (5xx errors). Lower is better.'
            icon: alert-triangle
            query: |
              (kind == "server" or name == "apitoolkit-http-span")
              | summarize round(countif(status_code == "ERROR" or coalesce(attributes.http.response.status_code, 0) >= 500) * 100.0 / count(), 2) by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: '%'
            alert_threshold: 5
            warning_threshold: 2
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Apdex Score'
            description: 'Application Performance Index (0-1). Measures user satisfaction based on response times. >0.9 is excellent, <0.5 is poor.'
            icon: smile
            sql: "SELECT ROUND((SUM(CASE WHEN duration <= 500000000 THEN 1.0 WHEN duration <= 2000000000 THEN 0.5 ELSE 0 END)) / GREATEST(1, COUNT(*))::numeric, 2)::float FROM otel_logs_and_spans WHERE project_id='{{project_id}}' AND (kind = 'server' OR name = 'apitoolkit-http-span' OR name = 'monoscope.http') AND duration IS NOT NULL {{time_filter}}"
            unit: '/1.0'
            layout: { w: 3, h: 2 }

      # Secondary metrics row
      - type: group
        title: System Overview
        layout: { w: 12, h: 2 }
        children:
          - type: 'stat'
            title: 'Active Services'
            icon: server
            query: |
              resource.service.name != null
              | summarize dcount(resource.service.name)
            unit: services
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Total Requests'
            icon: list-tree
            query: |
              (kind == "server" or name == "apitoolkit-http-span" or name == "monoscope.http")
              | summarize count()
            unit: reqs
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'DB Systems'
            icon: database
            query: |
              attributes.db.system.name != null
              | summarize dcount(attributes.db.system.name)
            unit: systems
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Unique Endpoints'
            icon: route
            query: |
              (kind == "server" or name == "apitoolkit-http-span") and name != null
              | summarize dcount(name)
            unit: endpoints
            layout: { w: 3, h: 2 }

      # Services Table and Issues side by side
      - type: table
        title: Services Health
        description: 'Click a service row to view its detailed metrics in the Service tab.'
        layout: { w: 6, h: 6 }
        on_row_click:
          set_variable: service
          value: '{{row.service_name}}'
          navigate_to_tab: 'Service Summary'
        columns:
          - field: service_name
            title: Service
          - field: apdex
            title: Apdex
            columnType: number
          - field: throughput
            title: Throughput
            columnType: number
            unit: req/min
            progress: column_percent
          - field: error_rate
            title: Errors
            unit: '%'
            progress: value_percent
            progress_variant: error
          - field: p95_latency
            title: P95
            columnType: duration
            unit: ms
            progress: column_percent
        sql: "SELECT resource___service___name as service_name, ROUND((SUM(CASE WHEN duration <= 500000000 THEN 1.0 WHEN duration <= 2000000000 THEN 0.5 ELSE 0 END)) / GREATEST(1, COUNT(*))::numeric, 2)::text as apdex, ROUND((COUNT(*)::numeric / GREATEST(1, EXTRACT(EPOCH FROM (MAX(timestamp) - MIN(timestamp))) / 60)), 2)::text as throughput, ROUND((COUNT(*) FILTER (WHERE status_code = 'ERROR' OR COALESCE(attributes___http___response___status_code, 0) >= 500) * 100.0 / GREATEST(1, COUNT(*))::numeric), 2)::text as error_rate, ROUND((approx_percentile(0.95, percentile_agg(duration))::numeric / 1000000), 2)::text as p95_latency FROM otel_logs_and_spans WHERE project_id='{{project_id}}' AND resource___service___name IS NOT NULL AND kind = 'server' AND duration IS NOT NULL {{time_filter}} GROUP BY resource___service___name ORDER BY COUNT(*)::numeric / GREATEST(1, EXTRACT(EPOCH FROM (MAX(timestamp) - MIN(timestamp))) / 60) DESC LIMIT 50"

      # Anomalies/Issues widget
      - type: anomalies
        title: 'Ongoing Issues'
        layout: { w: 6, h: 6 }

      # Events by Service
      - type: 'timeseries'
        title: 'Events by Service'
        query: |
          resource.service.name != null
          | summarize count() by bin_auto(timestamp), resource.service.name
          | order by timestamp desc
          | limit 10000
        unit: events
        layout: { w: 6, h: 4 }

      # Error Rates by Service
      - type: 'timeseries'
        title: 'Error Rates by Service'
        theme: 'roma'
        query: |
          status_code == "ERROR" and resource.service.name != null
          | summarize count() by bin_auto(timestamp), resource.service.name
          | order by timestamp desc
          | limit 10000
        unit: errors
        layout: { w: 6, h: 4 }

      # HTTP Request Volume by Service
      - type: 'timeseries'
        title: 'HTTP Request Volume by Service'
        query: |
          resource.service.name != null and kind == "server"
          | summarize count() by bin_auto(timestamp), resource.service.name
          | order by timestamp desc
          | limit 10000
        unit: reqs
        layout: { w: 6, h: 4 }

      # HTTP Requests by Status Code
      - type: 'timeseries'
        title: 'HTTP Requests by Status Code'
        query: |
          (kind == "server" or name == "apitoolkit-http-span" or name == "monoscope.http") and attributes.http.response.status_code != null
          | summarize count() by bin_auto(timestamp), coalesce(tostring(attributes.http.response.status_code), "unknown")
          | order by timestamp desc
          | limit 10000
        unit: reqs
        layout: { w: 6, h: 4 }

      # HTTP Errors Distribution
      - type: 'timeseries'
        title: 'HTTP Errors (4xx & 5xx) - Incoming'
        theme: 'roma'
        query: |
          (kind == "server" or name == "apitoolkit-http-span" or name == "monoscope.http") and attributes.http.response.status_code != null and attributes.http.response.status_code >= 400
          | extend error_category = case(attributes.http.response.status_code >= 500, "5xx", attributes.http.response.status_code >= 400, "4xx", tostring(attributes.http.response.status_code))
          | summarize count() by bin_auto(timestamp), error_category
          | order by timestamp desc
          | limit 10000
        unit: errors
        layout: { w: 6, h: 4 }

      # Request Latency Percentiles
      - type: 'timeseries_line'
        title: 'Request Latency Percentiles'
        description: 'Response time distribution. P50 is median, P99 shows worst-case latency for 1% of requests.'
        hide_subtitle: true
        summarize_by: max
        query: |
          (kind == "server" or name == "apitoolkit-http-span" or name == "monoscope.http") and duration != null
          | summarize percentiles(duration, 50, 75, 90, 95, 99) by bin_auto(timestamp)
          | order by timestamp desc
        unit: ns
        layout: { w: 6, h: 4 }

      # Requests by Endpoint
      - type: 'timeseries'
        title: 'Requests by Endpoint'
        sql: |
          WITH top_endpoints AS (
            SELECT 
              attributes___http___request___method || ' ' || attributes___url___path as endpoint,
              COUNT(*) as total_count
            FROM otel_logs_and_spans
            WHERE project_id='{{project_id}}'
              AND (kind = 'server' OR name = 'apitoolkit-http-span' OR name = 'monoscope.http')
              AND attributes___http___response___status_code IS NOT NULL
              AND attributes___url___path IS NOT NULL
              {{time_filter}}
            GROUP BY endpoint
            ORDER BY total_count DESC
            LIMIT 10
          )
          SELECT 
            extract(epoch from time_bucket('{{rollup_interval}}', o.timestamp))::integer AS time,
            o.attributes___http___request___method || ' ' || o.attributes___url___path as endpoint,
            COUNT(*)::float as count
          FROM otel_logs_and_spans o
          INNER JOIN top_endpoints t ON (o.attributes___http___request___method || ' ' || o.attributes___url___path) = t.endpoint
          WHERE o.project_id='{{project_id}}'
            AND (o.kind = 'server' OR o.name = 'apitoolkit-http-span' OR o.name = 'monoscope.http')
            {{time_filter}}
          GROUP BY time, o.attributes___http___request___method, o.attributes___url___path
          ORDER BY time DESC
        unit: reqs
        layout: { w: 12, h: 4 }

  - name: Service
    icon: server
    requires: service
    widgets:
      # Service Health Indicators
      - type: group
        title: '{{var-service}} Health'
        layout: { w: 12, h: 4 }
        children:
          - type: 'timeseries_stat'
            title: 'Service Requests'
            icon: list-tree
            query: |
              resource.service.name == "{{var-service}}" and kind == "server"
              | summarize count() by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: reqs
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Service Error Rate'
            icon: bug
            query: |
              resource.service.name == "{{var-service}}" and kind == "server"
              | summarize round(countif(status_code == "ERROR" or coalesce(attributes.http.response.status_code, 0) >= 400) * 100.0 / count(), 2)
            unit: '%'
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Avg Latency'
            icon: activity
            query: |
              resource.service.name == "{{var-service}}" and kind == "server" and duration != null
              | summarize round(avg(duration) / 1000000, 2)
            unit: ms
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Endpoints'
            icon: routes
            query: |
              resource.service.name == "{{var-service}}" and kind == "server" and name != null
              | summarize dcount(name)
            unit: endpoints
            layout: { w: 3, h: 2 }

      # Total Service Requests by Status Code
      - type: 'timeseries'
        title: 'Total Service Requests'
        query: |
          resource.service.name == "{{var-service}}" and kind == "server"
          | extend status_code_str = coalesce(tostring(attributes.http.response.status_code), "unknown")
          | summarize count() by bin_auto(timestamp), status_code_str
          | order by timestamp desc
          | limit 10000
        unit: reqs
        layout: { w: 6, h: 4 }

      # Service Latency Percentiles
      - type: 'timeseries_line'
        title: 'Service Latency Percentiles'
        hide_subtitle: true
        summarize_by: max
        query: |
          resource.service.name == "{{var-service}}" and kind == "server" and duration != null
          | summarize percentiles(duration, 50, 75, 90, 95, 99) by bin_auto(timestamp)
          | order by timestamp desc
        unit: ns
        layout: { w: 6, h: 4 }

      # Service Errors (non-OK status codes)
      - type: 'timeseries'
        title: 'Service Errors'
        theme: 'roma'
        query: |
          resource.service.name == "{{var-service}}" and kind == "server" and (status_code != "UNSET" and status_code != "OK" or coalesce(attributes.http.response.status_code, 0) >= 400)
          | extend error_type = case(status_code == "ERROR", "ERROR", attributes.http.response.status_code >= 500, "5xx", attributes.http.response.status_code >= 400, "4xx", status_code)
          | summarize count() by bin_auto(timestamp), error_type
          | order by timestamp desc
          | limit 10000
        unit: errors
        layout: { w: 6, h: 4 }

      # Time Spent by Downstream Operations
      - type: 'timeseries'
        title: 'Time Spent by Downstream Operations'
        sql: |
          WITH service_spans AS (
            SELECT
              extract(epoch from time_bucket('{{rollup_interval}}', timestamp))::integer AS time,
              context___span_id as span_id,
              context___trace_id as trace_id
            FROM otel_logs_and_spans
            WHERE project_id='{{project_id}}'
              AND resource___service___name = '{{var-service}}'
              AND kind = 'server'
              {{time_filter}}
          ),
          downstream_time AS (
            SELECT
              ss.time,
              o.name as operation,
              SUM(o.duration)::float as duration_ns
            FROM otel_logs_and_spans o
            INNER JOIN service_spans ss ON o.context___trace_id = ss.trace_id AND o.parent_id = ss.span_id
            WHERE o.project_id='{{project_id}}'
              AND o.duration IS NOT NULL
              AND o.name IS NOT NULL
              {{time_filter}}
            GROUP BY ss.time, o.name
          )
          SELECT
            time,
            operation,
            duration_ns as value
          FROM downstream_time
          ORDER BY time DESC
          LIMIT 10000
        unit: ns
        layout: { w: 6, h: 4 }

      # Operations Table
      - type: table
        title: Operations
        layout: { w: 12, h: 6 }
        columns:
          - field: operation_name
            title: Operation
          - field: count
            title: Count
            columnType: number
            progress: column_percent
          - field: error_rate
            title: Error Rate
            unit: '%'
            progress: value_percent
            progress_variant: error
          - field: avg_duration
            title: Avg Duration
            columnType: duration
            unit: ms
            progress: column_percent
          - field: p95_duration
            title: P95 Duration
            columnType: duration
            unit: ms
            progress: column_percent
        sql: |
          SELECT 
            name as operation_name,
            COUNT(*)::text as count,
            ROUND((COUNT(*) FILTER (WHERE status_code = 'ERROR' OR COALESCE(attributes___http___response___status_code, 0) >= 400) * 100.0 / GREATEST(1, COUNT(*)))::numeric, 2)::text as error_rate,
            ROUND((AVG(duration) / 1e6)::numeric, 2)::text as avg_duration,
            ROUND((approx_percentile(0.95, percentile_agg(duration))::numeric / 1e6), 2)::text as p95_duration
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND resource___service___name = '{{var-service}}'
            AND name IS NOT NULL
            AND duration IS NOT NULL
            {{time_filter}}
          GROUP BY name
          ORDER BY COUNT(*) DESC
          LIMIT 100

  - name: Resources
    icon: routes
    widgets:
      # Three charts in one row - using {{const-top_resources}} constant for efficiency
      - type: 'timeseries'
        title: 'Requests'
        query: |
          name != null and kind == "server" and ("{{var-resource}}" == "" or name == "{{var-resource}}")
          | extend resource = case(name in {{const-top_resources}}, name, "Others")
          | summarize count() by bin_auto(timestamp), resource
          | order by timestamp desc
          | limit 2000
        unit: reqs
        layout: { w: 4, h: 3 }

      - type: 'timeseries_line'
        title: 'P95 Latency'
        query: |
          name != null and kind == "server" and duration != null and ("{{var-resource}}" == "" or name == "{{var-resource}}")
          | extend resource = case(name in {{const-top_resources}}, name, "Others")
          | summarize p95(duration) by bin_auto(timestamp), resource
          | order by timestamp desc
          | limit 2000
        unit: ns
        layout: { w: 4, h: 3 }

      - type: 'timeseries'
        title: 'Errors'
        theme: 'roma'
        query: |
          name != null and kind == "server" and (status_code == "ERROR" or coalesce(attributes.http.response.status_code, 0) >= 400) and ("{{var-resource}}" == "" or name == "{{var-resource}}")
          | extend resource = case(name in {{const-top_resources}}, name, "Others")
          | summarize count() by bin_auto(timestamp), resource
          | order by timestamp desc
          | limit 2000
        unit: errors
        layout: { w: 4, h: 3 }

      # Full width resource table
      - type: table
        title: 'Resources Overview'
        description: 'Click a resource to filter charts above. Total Time shows cumulative time spent on each resource.'
        layout: { w: 12, h: 8 }
        on_row_click:
          set_variable: resource
          value: '{{row.resource_name}}'
        columns:
          - field: resource_name
            title: Resource Name
          - field: requests
            title: Requests
            columnType: number
            progress: column_percent
          - field: total_time
            title: Total Time
            columnType: duration
            unit: s
            progress: column_percent
          - field: p95_latency
            title: P95 Latency
            columnType: duration
            unit: ms
            progress: column_percent
          - field: errors
            title: Errors
            columnType: number
            progress: column_percent
            progress_variant: error
          - field: error_rate
            title: Error Rate (%)
            progress: value_percent
            progress_variant: error
        sql: |
          SELECT 
            name as resource_name,
            COUNT(*)::text as requests,
            ROUND((SUM(duration) / 1e9)::numeric, 2)::text as total_time,
            ROUND((approx_percentile(0.95, percentile_agg(duration))::numeric / 1e6), 2)::text as p95_latency,
            COUNT(*) FILTER (WHERE status_code = 'ERROR' OR COALESCE(attributes___http___response___status_code, 0) >= 400)::text as errors,
            ROUND((COUNT(*) FILTER (WHERE status_code = 'ERROR' OR COALESCE(attributes___http___response___status_code, 0) >= 400) * 100.0 / GREATEST(1, COUNT(*)))::numeric, 2)::text as error_rate
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND name IS NOT NULL
            AND kind = 'server'
            {{time_filter}}
          GROUP BY name
          ORDER BY COUNT(*) DESC
          LIMIT 100

  - name: Traces
    icon: activity
    widgets:
      # Trace Overview Stats
      - type: group
        title: Tracing Overview
        layout: { w: 12, h: 4 }
        children:
          - type: 'timeseries_stat'
            title: 'Total Spans'
            icon: list-tree
            query: |
              kind != null
              | summarize count() by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: spans
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Error Rate'
            icon: bug
            query: |
              kind != null
              | summarize round(countif(status_code == "ERROR") * 100.0 / count(), 2)
            unit: '%'
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Avg Trace Duration'
            description: 'Average end-to-end time for complete request traces, from entry to final response.'
            icon: activity
            query: |
              parent_id == "" and duration != null
              | summarize round(avg(duration) / 1000000, 2)
            unit: ms
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Traces'
            icon: route
            query: |
              parent_id == ""
              | summarize dcount(context.trace_id)
            unit: traces
            layout: { w: 3, h: 2 }

      # Span Rate by Service
      - type: 'timeseries'
        title: 'Span Rate by Service'
        query: |
          resource.service.name != null and ("{{var-service}}" == "" or resource.service.name == "{{var-service}}")
          | summarize count() / 5.0 by bin_auto(timestamp), resource.service.name
          | order by timestamp desc
          | limit 10000
        unit: spans/min
        layout: { w: 6, h: 4 }

      # Span Duration by Operation
      - type: 'timeseries'
        title: 'Span Duration by Operation'
        sql: |
          WITH operation_stats AS (
            SELECT
              name,
              AVG(duration) as avg_duration_ns
            FROM otel_logs_and_spans
            WHERE project_id='{{project_id}}'
              AND name IS NOT NULL
              AND ('{{var-service}}' = '' OR resource___service___name = '{{var-service}}')
              AND duration IS NOT NULL
              {{time_filter}}
            GROUP BY name
            ORDER BY avg_duration_ns DESC
            LIMIT 10
          )
          SELECT
            extract(epoch from time_bucket('{{rollup_interval}}', timestamp))::integer AS time,
            o.name,
            AVG(o.duration)::float as value
          FROM otel_logs_and_spans o
          INNER JOIN operation_stats s ON o.name = s.name
          WHERE o.project_id='{{project_id}}'
            AND ('{{var-service}}' = '' OR o.resource___service___name = '{{var-service}}')
            AND o.duration IS NOT NULL
            {{time_filter}}
          GROUP BY time, o.name
          ORDER BY time DESC
        unit: ns
        layout: { w: 6, h: 4 }

      # Trace List
      - type: traces
        title: 'Recent Traces'
        layout: { w: 12, h: 9 }
        columns:
          - field: resource_name
            title: Resource
          - field: span_name
            title: Span
            columnType: number
          - field: total_time
            title: Avg Duration
            columnType: duration
          - field: span_count
            title: Trace Count
            columnType: number
          - field: latency_breakdown
            title: Latency breakdown
        sql: |
          SELECT
            COALESCE(resource___service___name,'Unknown'),
            name,
            ROUND(AVG(duration/1000000), 2)::text AS avg_duration,
            COUNT(*)::text AS span_count,
            MIN(context___trace_id) AS trace_id
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND (parent_id = '' OR parent_id IS NULL) 
            AND name IS NOT NULL
            AND duration IS NOT NULL
            AND ('{{var-service}}' = '' OR resource___service___name = '{{var-service}}')
            {{time_filter}}
          GROUP BY  resource___service___name, name
          ORDER BY avg_duration DESC
          LIMIT 20

  - name: Logs
    icon: file-text
    widgets:
      # Log Stats - Enhanced with timeseries
      - type: group
        title: Log Metrics
        layout: { w: 12, h: 4 }
        children:
          - type: 'timeseries_stat'
            title: 'Total Logs'
            icon: file-text
            query: |
              body != null and ("{{var-service}}" == "" or resource.service.name == "{{var-service}}")
              | summarize count() by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: logs
            layout: { w: 3, h: 2 }

          - type: 'timeseries_stat'
            title: 'Error Logs'
            icon: alert-triangle
            query: |
              level in ("ERROR", "FATAL") and ("{{var-service}}" == "" or resource.service.name == "{{var-service}}")
              | summarize count() by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: errors
            alert_threshold: 100
            warning_threshold: 50
            layout: { w: 3, h: 2 }

          - type: 'timeseries_stat'
            title: 'Warning Logs'
            icon: alert-circle
            query: |
              level == "WARN" and ("{{var-service}}" == "" or resource.service.name == "{{var-service}}")
              | summarize count() by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: warns
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Log Sources'
            icon: server
            query: |
              body != null and resource.service.name != null
              | summarize dcount(resource.service.name)
            unit: services
            layout: { w: 3, h: 2 }

      # Log Volume Time Series
      - type: 'timeseries'
        title: 'Log Volume by Level'
        query: |
          level != null and ("{{var-service}}" == "" or resource.service.name == "{{var-service}}")
          | summarize count() by bin_auto(timestamp), level
          | order by timestamp desc
          | limit 10000
        layout: { w: 6, h: 4 }

      # Error Log Trends by Service
      - type: 'timeseries'
        title: 'Error Logs by Service'
        theme: 'roma'
        sql: |
          WITH service_stats AS (
            SELECT resource___service___name, COUNT(*) as error_count
            FROM otel_logs_and_spans
            WHERE project_id='{{project_id}}' AND level IN ('ERROR', 'FATAL')
              AND ('{{var-service}}' = '' OR resource___service___name = '{{var-service}}')
              {{time_filter}}
            GROUP BY resource___service___name
            ORDER BY error_count DESC
            LIMIT 10
          )
          SELECT
            extract(epoch from time_bucket('{{rollup_interval}}', timestamp))::integer AS time,
            o.resource___service___name as service_name,
            COUNT(*)::float as count
          FROM otel_logs_and_spans o
          INNER JOIN service_stats s ON o.resource___service___name = s.resource___service___name
          WHERE o.project_id='{{project_id}}' AND o.level IN ('ERROR', 'FATAL')
            AND ('{{var-service}}' = '' OR o.resource___service___name = '{{var-service}}')
            {{time_filter}}
          GROUP BY time, service_name
          ORDER BY time DESC
        layout: { w: 6, h: 4 }

      # Top Error Patterns - NEW: Grouped error analysis
      - type: table
        title: 'Top Error Patterns'
        description: 'Most frequent error messages grouped by pattern. Focus on high-count errors first.'
        layout: { w: 6, h: 6 }
        columns:
          - field: error_pattern
            title: Error Pattern
          - field: count
            title: Count
            columnType: number
            progress: column_percent
          - field: service
            title: Service
          - field: last_seen
            title: Last Seen
        sql: |
          SELECT
            LEFT(COALESCE(
              attributes___exception___message,
              attributes___exception___type,
              body::text,
              status_message
            ), 80) as error_pattern,
            COUNT(*)::text as count,
            resource___service___name as service,
            MAX(timestamp)::text as last_seen
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND (level IN ('ERROR', 'FATAL') OR status_code = 'ERROR')
            AND ('{{var-service}}' = '' OR resource___service___name = '{{var-service}}')
            {{time_filter}}
          GROUP BY error_pattern, service
          ORDER BY COUNT(*) DESC
          LIMIT 20

      # Logs by Service Distribution
      - type: 'tree_map'
        title: 'Logs by Service'
        layout: { w: 6, h: 6 }
        sql: |
          SELECT
            COALESCE(resource___service___name, 'Unknown') as service,
            COUNT(*)::float as count
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND body IS NOT NULL
            AND ('{{var-service}}' = '' OR resource___service___name = '{{var-service}}')
            {{time_filter}}
          GROUP BY service
          ORDER BY count DESC
          LIMIT 20

      # Recent Error Logs with Trace Links
      - type: table
        title: 'Recent Errors'
        layout: { w: 12, h: 5 }
        columns:
          - field: timestamp
            title: Time
          - field: service
            title: Service
          - field: error_message
            title: Error
          - field: trace_id
            title: Trace ID
        sql: |
          SELECT
            timestamp::text,
            resource___service___name as service,
            LEFT(COALESCE(attributes___exception___message, body::text, status_message), 100) as error_message,
            context___trace_id as trace_id
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND (level IN ('ERROR', 'FATAL') OR status_code = 'ERROR')
            AND ('{{var-service}}' = '' OR resource___service___name = '{{var-service}}')
            {{time_filter}}
          ORDER BY timestamp DESC
          LIMIT 50

      # Log Stream
      - type: logs
        title: 'Log Stream'
        layout: { w: 12, h: 8 }
        sql: |
          SELECT *
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND body IS NOT NULL
            AND ('{{var-service}}' = '' OR resource___service___name = '{{var-service}}')
            AND ('{{var-resource}}' = '' OR name = '{{var-resource}}')
            {{time_filter}}
          ORDER BY timestamp DESC
          LIMIT 500

  - name: Databases
    icon: database
    widgets:
      # Database Performance Metrics - Enhanced
      - type: group
        title: Database Performance
        layout: { w: 12, h: 4 }
        children:
          - type: 'timeseries_stat'
            title: 'Total Queries'
            icon: database
            query: |
              attributes.db.system.name != null and ("{{var-database}}" == "" or attributes.db.system.name == "{{var-database}}")
              | summarize count() by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: queries
            layout: { w: 3, h: 2 }

          - type: 'timeseries_stat'
            title: 'Query Error Rate'
            icon: alert-triangle
            query: |
              attributes.db.system.name != null and ("{{var-database}}" == "" or attributes.db.system.name == "{{var-database}}")
              | summarize round(countif(status_code == "ERROR") * 100.0 / count(), 2) by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: '%'
            alert_threshold: 5
            warning_threshold: 1
            layout: { w: 3, h: 2 }

          - type: 'timeseries_stat'
            title: 'P95 Query Time'
            icon: clock
            query: |
              attributes.db.system.name != null and duration != null and ("{{var-database}}" == "" or attributes.db.system.name == "{{var-database}}")
              | summarize p95(duration) / 1000000 by bin_auto(timestamp)
              | order by timestamp desc
              | limit 200
            unit: ms
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Slow Queries (>100ms)'
            description: 'Database queries taking over 100ms. High counts may indicate missing indexes or inefficient queries.'
            icon: turtle
            sql: |
              SELECT COUNT(*)::text
              FROM otel_logs_and_spans
              WHERE project_id='{{project_id}}'
                AND attributes___db___system___name IS NOT NULL
                AND duration > 100000000
                AND ('{{var-database}}' = '' OR attributes___db___system___name = '{{var-database}}')
                {{time_filter}}
            unit: queries
            layout: { w: 3, h: 2 }

      # TOP: Query Optimization Targets - Sorted by TOTAL TIME spent
      - type: table
        title: 'Query Optimization Targets (by Total Time)'
        description: 'Queries sorted by total time spent. Optimizing these yields the biggest performance gains.'
        layout: { w: 12, h: 7 }
        columns:
          - field: query_pattern
            title: Query Pattern
          - field: count
            title: Count
            columnType: number
            progress: column_percent
          - field: avg_ms
            title: Avg
            columnType: duration
            unit: ms
          - field: p95_ms
            title: P95
            columnType: duration
            unit: ms
          - field: total_time
            title: Total Time
            columnType: duration
            unit: s
            progress: column_percent
          - field: error_rate
            title: Errors
            unit: '%'
            progress: value_percent
            progress_variant: error
        sql: |
          SELECT
            LEFT(COALESCE(attributes___db___query___summary, attributes___db___query___text, name), 80) as query_pattern,
            COUNT(*)::text as count,
            ROUND((AVG(duration) / 1e6)::numeric, 2)::text as avg_ms,
            ROUND((approx_percentile(0.95, percentile_agg(duration)) / 1e6)::numeric, 2)::text as p95_ms,
            ROUND((SUM(duration) / 1e9)::numeric, 2)::text as total_time,
            ROUND((COUNT(*) FILTER (WHERE status_code = 'ERROR') * 100.0 / GREATEST(1, COUNT(*)))::numeric, 2)::text as error_rate
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND attributes___db___system___name IS NOT NULL
            AND duration IS NOT NULL
            AND ('{{var-database}}' = '' OR attributes___db___system___name = '{{var-database}}')
            {{time_filter}}
          GROUP BY query_pattern
          ORDER BY SUM(duration) DESC
          LIMIT 30

      # Database Systems Overview
      - type: table
        title: 'Database Systems'
        layout: { w: 6, h: 5 }
        on_row_click:
          set_variable: database
          value: '{{row.db_system}}'
        columns:
          - field: db_system
            title: Database
          - field: operations
            title: Count
            columnType: number
            progress: column_percent
          - field: avg_duration
            title: Avg
            columnType: duration
            unit: ms
          - field: error_rate
            title: Errors
            unit: '%'
            progress: value_percent
            progress_variant: error
        sql: |
          SELECT
            attributes___db___system___name as db_system,
            COUNT(*)::text as operations,
            ROUND((AVG(duration) / 1e6)::numeric, 2)::text as avg_duration,
            ROUND((COUNT(*) FILTER (WHERE status_code = 'ERROR') * 100.0 / GREATEST(1, COUNT(*)))::numeric, 2)::text as error_rate
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND attributes___db___system___name IS NOT NULL
            AND duration IS NOT NULL
            {{time_filter}}
          GROUP BY db_system
          ORDER BY COUNT(*) DESC

      # Queries by Operation Type
      - type: table
        title: 'Queries by Operation Type'
        layout: { w: 6, h: 5 }
        columns:
          - field: operation
            title: Operation
          - field: count
            title: Count
            columnType: number
            progress: column_percent
          - field: avg_ms
            title: Avg
            columnType: duration
            unit: ms
          - field: error_rate
            title: Errors
            unit: '%'
            progress: value_percent
            progress_variant: error
        sql: |
          SELECT
            UPPER(COALESCE(attributes___db___operation___name, SPLIT_PART(name, ' ', 1), 'UNKNOWN')) as operation,
            COUNT(*)::text as count,
            ROUND((AVG(duration) / 1e6)::numeric, 2)::text as avg_ms,
            ROUND((COUNT(*) FILTER (WHERE status_code = 'ERROR') * 100.0 / GREATEST(1, COUNT(*)))::numeric, 2)::text as error_rate
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND attributes___db___system___name IS NOT NULL
            AND duration IS NOT NULL
            AND ('{{var-database}}' = '' OR attributes___db___system___name = '{{var-database}}')
            {{time_filter}}
          GROUP BY operation
          ORDER BY COUNT(*) DESC
          LIMIT 10

      # Query Latency Over Time
      - type: 'timeseries_line'
        title: 'Query Latency Percentiles'
        query: |
          attributes.db.system.name != null and duration != null and ("{{var-database}}" == "" or attributes.db.system.name == "{{var-database}}")
          | summarize percentiles(duration, 50, 95, 99) by bin_auto(timestamp)
          | order by timestamp desc
        unit: ns
        layout: { w: 6, h: 4 }

      # Query Volume Over Time
      - type: 'timeseries'
        title: 'Query Volume by Database'
        query: |
          attributes.db.system.name != null and ("{{var-database}}" == "" or attributes.db.system.name == "{{var-database}}")
          | summarize count() by bin_auto(timestamp), attributes.db.system.name
          | order by timestamp desc
          | limit 10000
        unit: queries
        layout: { w: 6, h: 4 }

      # Recent Slow Queries (individual)
      - type: table
        title: 'Recent Slow Queries (>50ms)'
        layout: { w: 12, h: 5 }
        columns:
          - field: timestamp
            title: Time
          - field: query
            title: Query
          - field: duration_ms
            title: Duration
            columnType: duration
            unit: ms
            progress: column_percent
          - field: service
            title: Service
          - field: database
            title: DB
        sql: |
          SELECT
            timestamp::text,
            LEFT(COALESCE(attributes___db___query___text, attributes___db___query___summary, name), 80) as query,
            ROUND((duration / 1e6)::numeric, 2) as duration_ms,
            resource___service___name as service,
            attributes___db___system___name as database
          FROM otel_logs_and_spans
          WHERE project_id='{{project_id}}'
            AND attributes___db___system___name IS NOT NULL
            AND duration > 50000000
            AND ('{{var-database}}' = '' OR attributes___db___system___name = '{{var-database}}')
            {{time_filter}}
          ORDER BY timestamp DESC
          LIMIT 30

      # Database Errors
      - type: 'timeseries'
        title: 'Database Errors'
        theme: 'roma'
        query: |
          attributes.db.system.name != null and status_code == "ERROR" and ("{{var-database}}" == "" or attributes.db.system.name == "{{var-database}}")
          | summarize count() by bin_auto(timestamp), attributes.db.system.name
          | order by timestamp desc
          | limit 10000
        layout: { w: 6, h: 4 }

      # Connection Pool Status
      - type: 'timeseries'
        title: 'Database Connections'
        query: |
          name has "connection" and attributes.db.system.name != null and ("{{var-database}}" == "" or attributes.db.system.name == "{{var-database}}")
          | summarize count() by bin_auto(timestamp), coalesce(attributes.db.collection.name, "default")
          | order by timestamp desc
          | limit 10000
        layout: { w: 6, h: 4 }

  - name: Infra
    icon: server
    widgets:
      # Infrastructure Overview Stats
      - type: group
        title: Resource Utilization
        layout: { w: 12, h: 4 }
        children:
          - type: 'stat'
            title: 'Avg CPU Utilization'
            icon: cpu
            sql: |
              SELECT ROUND(AVG((metric_value->'contents'->>'value')::numeric * 100), 1)::text || '%'
              FROM telemetry.metrics
              WHERE project_id='{{project_id}}'
                AND metric_name IN ('container.cpu.utilization', 'process.cpu.utilization', 'jvm.cpu.recent_utilization')
                {{time_filter}}
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Avg Memory Usage'
            icon: hard-drive
            sql: |
              SELECT ROUND(AVG((metric_value->'contents'->>'value')::numeric), 1)::text || '%'
              FROM telemetry.metrics
              WHERE project_id='{{project_id}}'
                AND metric_name = 'container.memory.percent'
                {{time_filter}}
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Container Count'
            icon: box
            sql: |
              SELECT COUNT(DISTINCT resource->'container'->>'name')::text
              FROM telemetry.metrics
              WHERE project_id='{{project_id}}'
                AND resource->'container'->>'name' IS NOT NULL
                {{time_filter}}
            layout: { w: 3, h: 2 }

          - type: 'stat'
            title: 'Services with Metrics'
            icon: layers
            sql: |
              SELECT COUNT(DISTINCT resource->'service'->>'name')::text
              FROM telemetry.metrics
              WHERE project_id='{{project_id}}'
                AND resource->'service'->>'name' IS NOT NULL
                {{time_filter}}
            layout: { w: 3, h: 2 }

      # CPU Utilization Over Time
      - type: 'timeseries'
        title: 'CPU Utilization by Service'
        layout: { w: 6, h: 5 }
        sql: |
          SELECT
            time_bucket('1 minute', timestamp) as timestamp,
            COALESCE(resource->'service'->>'name', resource->'container'->>'name', 'unknown') as series,
            ROUND(AVG((metric_value->'contents'->>'value')::numeric * 100)::numeric, 2) as value
          FROM telemetry.metrics
          WHERE project_id='{{project_id}}'
            AND metric_name IN ('container.cpu.utilization', 'jvm.cpu.recent_utilization', 'process.cpu.utilization')
            {{time_filter}}
          GROUP BY time_bucket('1 minute', timestamp), series
          ORDER BY timestamp DESC
          LIMIT 2000
        unit: '%'

      # Memory Usage Over Time
      - type: 'timeseries'
        title: 'Memory Usage by Service'
        layout: { w: 6, h: 5 }
        sql: |
          SELECT
            time_bucket('1 minute', timestamp) as timestamp,
            COALESCE(resource->'service'->>'name', resource->'container'->>'name', 'unknown') as series,
            ROUND(AVG((metric_value->'contents'->>'value')::numeric)::numeric, 2) as value
          FROM telemetry.metrics
          WHERE project_id='{{project_id}}'
            AND metric_name = 'container.memory.percent'
            {{time_filter}}
          GROUP BY time_bucket('1 minute', timestamp), series
          ORDER BY timestamp DESC
          LIMIT 2000
        unit: '%'

      # Container/Service Resource Table
      - type: table
        title: 'Service Resource Usage'
        layout: { w: 12, h: 6 }
        columns:
          - field: service
            title: Service/Container
          - field: cpu_avg
            title: CPU Avg
            unit: '%'
            progress: value_percent
          - field: cpu_max
            title: CPU Max
            unit: '%'
            progress: value_percent
            progress_variant: warning
          - field: mem_avg
            title: Mem Avg
            unit: '%'
            progress: value_percent
          - field: mem_max
            title: Mem Max
            unit: '%'
            progress: value_percent
            progress_variant: warning
          - field: data_points
            title: Samples
            columnType: number
        sql: |
          WITH cpu_metrics AS (
            SELECT
              COALESCE(resource->'service'->>'name', resource->'container'->>'name', 'unknown') as service,
              (metric_value->'contents'->>'value')::numeric * 100 as value
            FROM telemetry.metrics
            WHERE project_id='{{project_id}}'
              AND metric_name IN ('container.cpu.utilization', 'jvm.cpu.recent_utilization', 'process.cpu.utilization')
              {{time_filter}}
          ),
          mem_metrics AS (
            SELECT
              COALESCE(resource->'service'->>'name', resource->'container'->>'name', 'unknown') as service,
              (metric_value->'contents'->>'value')::numeric as value
            FROM telemetry.metrics
            WHERE project_id='{{project_id}}'
              AND metric_name = 'container.memory.percent'
              {{time_filter}}
          )
          SELECT
            COALESCE(c.service, m.service) as service,
            ROUND(AVG(c.value)::numeric, 1)::text as cpu_avg,
            ROUND(MAX(c.value)::numeric, 1)::text as cpu_max,
            ROUND(AVG(m.value)::numeric, 1)::text as mem_avg,
            ROUND(MAX(m.value)::numeric, 1)::text as mem_max,
            (COUNT(c.*) + COUNT(m.*))::text as data_points
          FROM cpu_metrics c
          FULL OUTER JOIN mem_metrics m ON c.service = m.service
          GROUP BY COALESCE(c.service, m.service)
          ORDER BY AVG(c.value) DESC NULLS LAST
          LIMIT 20

      # Kafka Consumer Metrics (if available)
      - type: 'timeseries'
        title: 'Kafka Consumer Lag'
        layout: { w: 6, h: 4 }
        sql: |
          SELECT
            time_bucket('1 minute', timestamp) as timestamp,
            COALESCE(resource->'service'->>'name', 'kafka') as series,
            AVG((metric_value->'contents'->>'value')::numeric) as value
          FROM telemetry.metrics
          WHERE project_id='{{project_id}}'
            AND metric_name = 'kafka.consumer.assigned_partitions'
            {{time_filter}}
          GROUP BY time_bucket('1 minute', timestamp), series
          ORDER BY timestamp DESC
          LIMIT 1000
        unit: partitions

      # System Load Average
      - type: 'timeseries'
        title: 'System Load Average'
        layout: { w: 6, h: 4 }
        sql: |
          SELECT
            time_bucket('1 minute', timestamp) as timestamp,
            CASE
              WHEN metric_name = 'system.cpu.load_average.1m' THEN '1 min'
              WHEN metric_name = 'system.cpu.load_average.5m' THEN '5 min'
              WHEN metric_name = 'system.cpu.load_average.15m' THEN '15 min'
            END as series,
            AVG((metric_value->'contents'->>'value')::numeric) as value
          FROM telemetry.metrics
          WHERE project_id='{{project_id}}'
            AND metric_name IN ('system.cpu.load_average.1m', 'system.cpu.load_average.5m', 'system.cpu.load_average.15m')
            {{time_filter}}
          GROUP BY time_bucket('1 minute', timestamp), metric_name
          ORDER BY timestamp DESC
          LIMIT 3000

      # Redis Memory (if available)
      - type: 'timeseries'
        title: 'Redis Memory Usage'
        layout: { w: 6, h: 4 }
        sql: |
          SELECT
            time_bucket('1 minute', timestamp) as timestamp,
            metric_name as series,
            AVG((metric_value->'contents'->>'value')::numeric) / 1048576 as value
          FROM telemetry.metrics
          WHERE project_id='{{project_id}}'
            AND metric_name IN ('redis.memory.used', 'redis.memory.rss', 'redis.memory.peak')
            {{time_filter}}
          GROUP BY time_bucket('1 minute', timestamp), metric_name
          ORDER BY timestamp DESC
          LIMIT 3000
        unit: MB

      # All Available Metrics List
      - type: table
        title: 'Available Metrics'
        layout: { w: 6, h: 4 }
        columns:
          - field: metric_name
            title: Metric
          - field: data_points
            title: Data Points
            columnType: number
            progress: column_percent
          - field: unit
            title: Unit
        sql: |
          SELECT
            metric_name,
            COUNT(*)::text as data_points,
            COALESCE(MAX(metric_unit), '-') as unit
          FROM telemetry.metrics
          WHERE project_id='{{project_id}}'
            {{time_filter}}
          GROUP BY metric_name
          ORDER BY COUNT(*) DESC
          LIMIT 20
