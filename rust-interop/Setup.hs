{-|
This file was generated by `cargo-cabal`, its goal is to define few hooks to
call `cargo` on the fly and link correctly the generated library.

While it's an acceptable hack as this project is currently a prototype, this
should be removed before `cargo-cabal` stable release.
-}

import Control.Monad (when, unless)
import Data.Maybe
import System.Environment (setEnv, lookupEnv)
import qualified Distribution.PackageDescription as PD
import Distribution.Simple
  ( Args,
    UserHooks (confHook, preConf),
    defaultMainWithHooks,
    simpleUserHooks,
  )
import Distribution.Simple.LocalBuildInfo ( LocalBuildInfo (localPkgDescr), buildDir)
import Distribution.Simple.Setup ( BuildFlags (buildVerbosity), ConfigFlags (configVerbosity), CopyFlags, fromFlag)
import Distribution.Simple.UserHooks
  ( UserHooks (buildHook, confHook, copyHook, instHook),
  )
import Distribution.Simple.Utils (rawSystemExit, installOrdinaryFile)
import System.Directory (getCurrentDirectory, copyFile, createDirectoryIfMissing, doesFileExist)
import System.FilePath ((</>))

main :: IO ()
main =
  defaultMainWithHooks
    simpleUserHooks
      { confHook = rustConfHook
      , copyHook = rustCopyHook
      -- , buildHook = rustBuildHook
      }

-- This hook could be removed at some point, likely if this issue is resolved
-- https://github.com/haskell/cabal/issues/2641

rustConfHook ::
  (PD.GenericPackageDescription, PD.HookedBuildInfo) ->
  ConfigFlags ->
  IO LocalBuildInfo
rustConfHook (description, buildInfo) flags = do
  localBuildInfo <- confHook simpleUserHooks (description, buildInfo) flags
  let packageDescription = localPkgDescr localBuildInfo
      library = fromJust $ PD.library packageDescription
      libraryBuildInfo = PD.libBuildInfo library
  dir <- getCurrentDirectory
  putStrLn $ "=== Adding library paths: " ++ show [dir ++ "/target/release", dir ++ "/target/debug"]
  return localBuildInfo
    { localPkgDescr = packageDescription
      { PD.library = Just $ library
        { PD.libBuildInfo = libraryBuildInfo
          { PD.extraLibDirs = (dir ++ "/target/release") :
                              -- (dir ++ "/target/debug") :
            PD.extraLibDirs libraryBuildInfo
    } } } }

rustCopyHook ::
  PD.PackageDescription ->
  LocalBuildInfo ->
  UserHooks ->
  CopyFlags ->
  IO ()
rustCopyHook description localBuildInfo hooks flags = do
  -- First, run the default copy hook
  copyHook simpleUserHooks description localBuildInfo hooks flags
  
  -- Then, ensure the Rust library is copied to the build directory
  dir <- getCurrentDirectory
  let distBuildDir = buildDir localBuildInfo
      libName = "libCrust_interop"
      srcDir = dir </> "target" </> "release"
  
  putStrLn $ "=== Copying Rust libraries for installation"
  putStrLn $ "=== Build directory: " ++ distBuildDir
  
  -- Create the destination directory if it doesn't exist
  createDirectoryIfMissing True distBuildDir
  
  -- Copy static library (.a)
  let srcPathA = srcDir </> (libName ++ ".a")
      dstPathA = distBuildDir </> (libName ++ ".a")
  srcExistsA <- doesFileExist srcPathA
  when srcExistsA $ do
    copyFile srcPathA dstPathA
    putStrLn $ "=== Successfully copied " ++ libName ++ ".a"
  
  -- Copy shared library (.so) if it exists (Linux)
  let srcPathSO = srcDir </> (libName ++ ".so")
      dstPathSO = distBuildDir </> (libName ++ ".so")
  srcExistsSO <- doesFileExist srcPathSO
  when srcExistsSO $ do
    copyFile srcPathSO dstPathSO
    putStrLn $ "=== Successfully copied " ++ libName ++ ".so"
  
  -- Copy dylib if it exists (macOS)
  let srcPathDylib = srcDir </> (libName ++ ".dylib")
      dstPathDylib = distBuildDir </> (libName ++ ".dylib")
  srcExistsDylib <- doesFileExist srcPathDylib
  when srcExistsDylib $ do
    copyFile srcPathDylib dstPathDylib
    putStrLn $ "=== Successfully copied " ++ libName ++ ".dylib"
  
  -- Warn if no library files were found
  unless (srcExistsA || srcExistsSO || srcExistsDylib) $
    putStrLn $ "=== WARNING: No library files found in " ++ srcDir

-- It would be nice to remove this hook at some point, e.g., if this RFC is merged
-- in Cabal https://github.com/haskell/cabal/issues/7906

rustBuildHook ::
  PD.PackageDescription ->
  LocalBuildInfo ->
  UserHooks ->
  BuildFlags ->
  IO ()
rustBuildHook description localBuildInfo hooks flags = do
  putStrLn "******************************************************************"
  putStrLn "Call `cargo build --release` to build a dependency written in Rust"
  -- FIXME: add `--target $TARGET` flag to support cross-compiling to $TARGET
  rawSystemExit (fromFlag $ buildVerbosity flags) "cargo" ["build","--release"]
  putStrLn "... `rustc` compilation seems to succeed ðŸ¦€! Back to Cabal build:"
  putStrLn "******************************************************************"
  putStrLn "Back to Cabal build"
  print $ PD.libBuildInfo $ fromJust (PD.library $ localPkgDescr localBuildInfo)
  let libDir = "/Users/tonyalaribe/Projects/apitoolkit/apitoolkit-server/rust-interop/target/release"
  currentEnv <- lookupEnv "DYLD_LIBRARY_PATH"
  print currentEnv
  setEnv "DYLD_LIBRARY_PATH" (libDir ++ ":" ++ fromMaybe "" currentEnv)
  putStrLn (libDir  ++ maybe "" (":"++) currentEnv)
  buildHook simpleUserHooks description localBuildInfo hooks flags

-- This handy automation (particularly useful when you want to quickly prototype
-- without having to spawn manually `cargo` commands) is disabled by default.
-- Feel free to re-enable it while debugging your library, but I discourage you
-- strongly to publish anything on Hackage that contains this hook!
