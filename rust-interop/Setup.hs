{-|
This file was generated by `cargo-cabal`, its goal is to define few hooks to
call `cargo` on the fly and link correctly the generated library.

While it's an acceptable hack as this project is currently a prototype, this
should be removed before `cargo-cabal` stable release.
-}

import Control.Monad (when, unless, forM)
import Data.Maybe
import Data.List (isPrefixOf, isInfixOf)
import System.Environment (setEnv, lookupEnv)
import qualified Distribution.PackageDescription as PD
import Distribution.Simple
  ( Args,
    UserHooks (confHook, preConf),
    defaultMainWithHooks,
    simpleUserHooks,
  )
import Distribution.Simple.LocalBuildInfo ( LocalBuildInfo (localPkgDescr), buildDir)
import Distribution.Simple.Setup ( BuildFlags (buildVerbosity), ConfigFlags (configVerbosity), CopyFlags, fromFlag)
import Distribution.Simple.UserHooks
  ( UserHooks (buildHook, confHook, copyHook, instHook),
  )
import Distribution.Simple.Utils (rawSystemExit, installOrdinaryFile)
import System.Directory (getCurrentDirectory, copyFile, createDirectoryIfMissing, doesFileExist)
import System.FilePath ((</>))

main :: IO ()
main =
  defaultMainWithHooks
    simpleUserHooks
      { confHook = rustConfHook
      , copyHook = rustCopyHook
      , buildHook = rustBuildHook
      }

-- This hook could be removed at some point, likely if this issue is resolved
-- https://github.com/haskell/cabal/issues/2641

rustConfHook ::
  (PD.GenericPackageDescription, PD.HookedBuildInfo) ->
  ConfigFlags ->
  IO LocalBuildInfo
rustConfHook (description, buildInfo) flags = do
  localBuildInfo <- confHook simpleUserHooks (description, buildInfo) flags
  let packageDescription = localPkgDescr localBuildInfo
      library = fromJust $ PD.library packageDescription
      libraryBuildInfo = PD.libBuildInfo library
  dir <- getCurrentDirectory
  putStrLn $ "=== Adding library paths: " ++ show [dir ++ "/target/release", dir ++ "/target/debug"]
  return localBuildInfo
    { localPkgDescr = packageDescription
      { PD.library = Just $ library
        { PD.libBuildInfo = libraryBuildInfo
          { PD.extraLibDirs = (dir ++ "/target/release") :
                              -- (dir ++ "/target/debug") :
            PD.extraLibDirs libraryBuildInfo
    } } } }

rustCopyHook ::
  PD.PackageDescription ->
  LocalBuildInfo ->
  UserHooks ->
  CopyFlags ->
  IO ()
rustCopyHook description localBuildInfo hooks flags = do
  -- First, run the default copy hook
  copyHook simpleUserHooks description localBuildInfo hooks flags
  
  -- Then, ensure the Rust library is copied to the build directory
  dir <- getCurrentDirectory
  let distBuildDir = buildDir localBuildInfo
      libName = "libCrust_interop"
  
  putStrLn $ "=== Copying Rust libraries for installation"
  putStrLn $ "=== Current directory: " ++ dir
  putStrLn $ "=== Build directory: " ++ distBuildDir
  
  -- Try multiple possible locations for the Rust libraries
  let possibleSrcDirs = [ dir </> "target" </> "release"           -- Local build
                        , "/usr/local/lib"                          -- System install
                        , "/usr/lib"                                -- Alternative system install
                        , distBuildDir                              -- Already in build dir
                        ]
  
  -- Create the destination directory if it doesn't exist
  createDirectoryIfMissing True distBuildDir
  
  -- Helper function to find and copy a library file
  let findAndCopyLib :: String -> IO Bool
      findAndCopyLib ext = do
        let fileName = libName ++ ext
            dstPath = distBuildDir </> fileName
        -- Check if already exists in destination
        dstExists <- doesFileExist dstPath
        if dstExists
          then do
            putStrLn $ "=== " ++ fileName ++ " already exists in build directory"
            return True
          else do
            -- Try to find the file in possible source directories
            results <- mapM (\srcDir -> do
              let srcPath = srcDir </> fileName
              exists <- doesFileExist srcPath
              if exists
                then do
                  putStrLn $ "=== Found " ++ fileName ++ " at " ++ srcPath
                  copyFile srcPath dstPath
                  putStrLn $ "=== Successfully copied " ++ fileName
                  return True
                else return False
              ) possibleSrcDirs
            return $ or results
  
  -- Copy all library types
  foundA <- findAndCopyLib ".a"
  foundSO <- findAndCopyLib ".so"
  foundDylib <- findAndCopyLib ".dylib"
  
  -- Warn if no library files were found
  unless (foundA || foundSO || foundDylib) $ do
    putStrLn $ "=== ERROR: No library files found in any of these locations:"
    mapM_ (\dir -> putStrLn $ "===   - " ++ dir) possibleSrcDirs
    error "Failed to find Rust library files"

-- It would be nice to remove this hook at some point, e.g., if this RFC is merged
-- in Cabal https://github.com/haskell/cabal/issues/7906

rustBuildHook ::
  PD.PackageDescription ->
  LocalBuildInfo ->
  UserHooks ->
  BuildFlags ->
  IO ()
rustBuildHook description localBuildInfo hooks flags = do
  dir <- getCurrentDirectory
  let distBuildDir = buildDir localBuildInfo
      libName = "libCrust_interop"
  
  putStrLn $ "=== Rust build hook"
  putStrLn $ "=== Current directory: " ++ dir
  putStrLn $ "=== Build directory: " ++ distBuildDir
  
  -- Check if we're in a temp directory (cabal install scenario)
  -- Also check if the rust libraries don't exist locally (indicating we need pre-built ones)
  localLibExists <- doesFileExist (dir </> "target" </> "release" </> (libName ++ ".a"))
  let inTempDir = "/tmp/" `isPrefixOf` dir 
                  || "cabal-install" `isInfixOf` dir 
                  || "/var/folders/" `isPrefixOf` dir  -- macOS temp dirs
                  || not localLibExists
  
  if inTempDir
    then do
      putStrLn "=== Detected cabal install from temp directory"
      -- Try to find pre-built libraries in system directories
      let systemDirs = ["/usr/local/lib", "/usr/lib"]
      
      -- Create build directory
      createDirectoryIfMissing True distBuildDir
      
      -- Copy libraries from system directories
      let copyLibFromSystem ext = do
            let fileName = libName ++ ext
            results <- forM systemDirs $ \sysDir -> do
              let srcPath = sysDir </> fileName
                  dstPath = distBuildDir </> fileName
              exists <- doesFileExist srcPath
              if exists
                then do
                  putStrLn $ "=== Copying " ++ fileName ++ " from " ++ srcPath
                  copyFile srcPath dstPath
                  return True
                else return False
            return $ or results
      
      foundA <- copyLibFromSystem ".a"
      foundSO <- copyLibFromSystem ".so"
      foundDylib <- copyLibFromSystem ".dylib"
      
      unless (foundA || foundSO || foundDylib) $
        error "Failed to find pre-built Rust libraries in system directories"
    else do
      -- Normal build scenario - check if Rust library already exists
      let releaseLibPath = dir </> "target" </> "release" </> (libName ++ ".a")
      libExists <- doesFileExist releaseLibPath
      
      if libExists
        then do
          putStrLn "=== Rust library already built, skipping cargo build"
          putStrLn $ "=== Found library at: " ++ releaseLibPath
        else do
          putStrLn "******************************************************************"
          putStrLn "Call `cargo build --release` to build a dependency written in Rust"
          rawSystemExit (fromFlag $ buildVerbosity flags) "cargo" ["build","--release"]
          putStrLn "... `rustc` compilation seems to succeed ðŸ¦€! Back to Cabal build:"
          putStrLn "******************************************************************"
  
  -- Continue with normal build
  buildHook simpleUserHooks description localBuildInfo hooks flags

-- This handy automation (particularly useful when you want to quickly prototype
-- without having to spawn manually `cargo` commands) is disabled by default.
-- Feel free to re-enable it while debugging your library, but I discourage you
-- strongly to publish anything on Hackage that contains this hook!
